---
layout: post
title: java, Spring 예상 면접관련 질문 정리
date: 2019-05-29 20:25:00 +0900
description:
categories: Java
tags: Spring java
---

블로그에서 좋은 글을 발견해서 나름대로 답변을 어떻게 할까 고민하면서 글을 정리해보려고 한다.

### 1) 자바의 특징에 대해서 말해보시오

* OOP : 객체지향언어로서, 프로그래밍에 필요한 데이터와 기능을 추상화하여 객체로 만들고 그 객체들간의 상호작용을 통해서 프로그램을 완성하는 개발 기법.
  
* 메모리를 관리해주는 언어, 가비지컬렉터가 관리해준다.

* 멀티쓰레드를 구현이 쉽다( 이미 잘 구현된 라이브러리가 많다 )

* JVM 위에서 동작하기 때문에 다양한 애플리케이션을 개발 할 수 있다( 윈도우, 리눅스, 유닉스, 맥 등)

* 풍부한 생태계를 지원한다 ( 강력하고 검증된 오픈소스 라이브러리가 많다 )

* 동적로딩을 지원한다 ( 모든 클래스가 동시에 로딩되는게 아니라, 필요한 시점에 객체를 생성한다. 변경사항이 생긴 객체만 다시 컴파일하면 된다)

* 구조중립적이며 이식성이 높다

* 보안성이 높다

### 2) 변수란?

* 값을 저장할 수 있는 메모리 공간

### 3) 클래스, 객체, 인스턴스의 개념

<b>클래스란?</b>

* 객체를 만들어내기 위한 설계도 혹은 틀
* 변수와 메서드의 집합 

<b>객체란?</b>

* 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
* oop의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.
* 소프트웨어 세계에 구현할 대상

<b>인스턴스란?</b>

* 실제 메모리에 할당된 객체
* oop의 관점으로 객체가 메모리에 할당되어 실제 사용되는 경우를 인스턴스라고 부른다  

### 4) 객체지향 프로그램의 특징은?

* 캡슐화, 상속, 다형성

  * 캡슐화 : 관련된 변수와 기능을 하나의 클래스로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체내부의 구조를 알지못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
  * 상속 : 부모 클래스의 속성과 기능을 그대로 이어받아서 사용할수 있고, 필요한 경우 기능을 다시 재정의해서 사용가능 
  * 다형성 : 하나의 변수명, 함수명등이 상황에 따라 다르게 사용될 수 있다, 즉 오버로딩 오버라이딩이 가능하다.
    * 오버라이딩 : 부모클래스의 메서드와 같은이름, 매개변수를 재정의하는 것
    * 오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 해서 매개변수에 따라 다르게 호출할 수 있게 하는것
    * 예시) 메소드나 생성자를 오버로딩을 통해서 다양한 매개변수에 대응할 수 있다. 생성자 같은 경우는 this를 통해서 중복코드를 최소화 할 수 있다.

```java

public class Car{
  private String name;
  private String color;
  private int maxSpeed;

  public Car(String name){ 
    // 생성자가 두가지 타입의 매개변수에 대응이 가능하다. 
    // 또한 this를 통해서 코드 중복을 줄일 수 있다.
    this(name, "검은색", 250);
  }

  public Car(String name, String color, int maxSpeed){
    this.name = name;
    this.color = color;
    this.maxSpeed = maxSpeed;
  }
}

```

* 장점
  * 코드 재사용이 용이하다
  * 유지보수가 쉽다
  * 대형프로젝트에 적합하다

* 단점
  * 처리속도가 느리다
  * 객체가 많을 경우 용량이 커질 수 있다
  * 설계시 많은 시간과 노력이 필요하다


### 5) 자바의 메모리 영역

* 메소드 영역 : 필드 부분에서 선언된 변수(전역 변수)와 각 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메소드 static 변수, 메서드의 바이트 코드등을 보관한다. jvm이 종료될 때까지 메모리에 남아있다. 그렇기 때문에 전역변수를 많이 사용하면 메모리에 악영향을 끼칠 수 있다.
* 스택 영역 : 지역변수( 기본 자료형 등)의 데이터값이 저장되는 공간이 stack 영역이다. stack 영역은 LIFO의 구조를 갖고, 새로운 데이터가 할당될 경우 이전 데이터는 지워진다.
* 힙 영역 : 인스턴스, 배열등이 headp 영역에 저장된다. Heap 영역의 메모리 참조값을 가지고 있다. 메모리가 부족해지면 GC가 Heap 영역에 있는 쓸모없는 데이터를 Young( eden, survive1,2 ), Old 영역에서 정리한다.
* 네이티브 스택 영역 : 자바언어가 아닌 다른 프로그래밍 언어 (C나 C++ 등)의 데이터가 저장된다.
* PC REGISTER : 스레드의 정보가 저장된다. 


### 6) 추상클래스, 메소드란?

* 추상 메서드
  * 메서드가 정의는 되어있으나, 내부가 구현되지 않은 메서드
* 추상 클래스
  * 클래스들의 공통되는 특성을 모은 클래스, 추상클래스는 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 객체를 직접 생성해서 사용할 수 없다. 추상클래스는 상속만을 통해서 사용할 수 있다.
  * 사용목적
    * 클래스들간의 공통된 필드와 메소드의 이름을 통일할 목적
      * 만약 하위 클래스들이 모두 같은 기능을 사용할 경우에는 추상클래스에서 메소드를 미리 작성하면 효율적이다. 그렇지만 만약에 하위 클래스들간에 서로 다른 기능을 구현해야 할 경우에는 선언만 통일화 시키고, 실제 내용은 하위클래스에서 구현한다.
    * 클래스를 작성할 때 시간을 절약할 수 있다. 
      * 즉 공통된 기능이나 규격을 미리 만들어놓고 구체적인 내용은 상속받은 하위클래스에서 구현한다.

* 번외
  * 추상클래스와 인터페이스는 어떤 차이가 있을까?
    * 인터페이스는 다중상속이 가능하다. 추상클래스는 불가능
    * 인터페이스는 오로지 추상메서드로만 이루어져 있다. 추상클래스는 일반메서드나 필드를 가질수 있다. 
    * 버전이 올라감에 있어서 인터페이스와 추상클래스간의 차이는 거이 없어졌다.
    * 가장 큰 차이는 추상클래스는 추상클래스의 기능을 이용하고, 확장시키는데 있고 인터페이스는 함수의 구현을 강제시키는데 목적이 있다( 동일한 동작을 약속하기 위함, 또한 설계 변경 확장 협업등에 용이하다 )

### 7) 인터페이스란? 

* 추상 메서드로(선언만 되어있는 메소드) 만 이루어져 있으며, 자동으로 static final이 붙는다. 인터페이스를 구현할 클래스에서 implements라는 키워드를 사용해야 한다. 구현을 강제하기 위해서 사용한다.

* <b>왜 사용하는가?</b> 협업에 적합하다. 인터페이스는 구현을 하지 않아도 어떤 값을 리턴할 것인지 알기 때문에 협업시에 구현과 동시에, 구현에 따른 결과값에 따른 부가작업을 동시에 진행할 수 있다. 또한 해당 객체가 수정되어도, 개발 코드 부분을 수정하지 않고 구현한 클래스에서만 수정하면 된다.

* 자바 8 버전부터는 default method라는게 생겼는데, 추상클래스처럼 인터페이스에서도 메소드를 구현할 수 있다. 또한 이를 구현하는 클래스는 default method를 오버라이딩 할 수 있다.
* static method도 자바 8버전부터 추가된 기능인데, 인터페이스를 통해서 미리 구현한 메소드를 사용할 수 있다. 사용하기 위해서는 인터페이스명.메소드명 ex) interfaceName.staticMethod 로 접근할 수 있다.

* 디폴트 메소드 vs 정적 메소드
  * 디폴트 메소드는 구현하고 있는 클래스에서 재정의가 가능, 반대로 정적 메소드는 재정의가 불가능하다. 

* 자바 8부터는 익명 구현 객체를 지원한다. 보통 임시작업 스레드를 만들거나, UI 프로그래밍에서 이벤트를 처리할때 많이 활용한다. 람다식의 문법은 아래와 같다.
  
```java

interface 변수 = new interface() {
  public void 추상메소드1 { 실행 코드 }
  public void 추상메소드2 { 실행 코드 }
};

```

### 8-1) 프로세스, 쓰레드의 차이점

<b>프로세스란?</b>
* 프로세스는 실행된 프로그램의 인스턴스이다( OS로부터 메모리를 할당받은 독립적인 객체 ). 
* 특징
  * 프로세스는 하나의 독립적인 메모리 공간을 가지고 있다.
  * 기본적으로 프로세스는 하나의 쓰레드를 가지고 있다.
  * 각 프로세스는 별도의 주소공간( 메모리 주소 )에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
  * 그럼 다른 프로세스에 접근할려면? IPC 통신을 사용해야한다 EX) 파이프, 파일, 소켓 등등

<b>스레드란?</b>
* 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 동작하는 작업 단위이다.
* 프로세스가 할당받은 자원을 사용하는 실행의 단위 ( 실제로 일을 할당받아 처리하는 일꾼과 비슷하다 )
* 특징
  * 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
  * 프로세스와 다르게 스레드는 같은 힙공간을 공유한다 ( 스레드는 각각 별도의 Stack과 주소를 가지고 있지만 힙영역은 공유가 가능하다. )
  * 한 스레드가, 프로세스 자원을 변경하면 다른 이웃스레드도 그 변경결과를 즉시 볼 수 있다.
  * 멀티스레드 프로그래밍에서는 스레드의 상태 제어가 굉장히 중요하다. 잘못 사용할 경우 치명적인 프로그램의 버그를 야기하고 어플리케이션이 먹통이 될 수 있다.

### 8-2) 멀티프로세스, 멀티 스레드의 차이

<b>멀티프로세스란?</b>

* 하나의 프로그램을 여러개의 프로세스로 구성하여, 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.
   
* 장점
  * 프로세스는 OS로부터 각각 독립적인 메모리를 할당받기 때문에, 하나에 문제가 생겨서 프로세스가 종료되도 다른 프로세스에는 영향을 끼치지 않습니다.

* 단점
  * Context Switching에서의 오버헤드가 발생 ( 캐쉬 메모리 초기화 등 ) 무거운 작업을 실행하는 동안 많은 시간이 소요된다.
  * 프로세스는 각각 독립된 메모리 영역을 할당받아서 공유할려면 IPC 통신을 사용해야 한다. ( 통신이 어려움 )

<b>멀티스레드란?</b>

* 하나의 프로그램을 여러개의 스레드로 처리하는것. 윈도우, 리눅스 등 많은 OS가 멀티프로세싱을 지원하고 있지만, 멀티스레딩을 기본으로 하고 있다.
* 웹 서버, 소켓통신 대표적인 멀티스레드의 대표적인 예이다.

* 장점
  * 시스템 자원소모감소
    * 프로세스를 여러개 생성하는 것보다 자원을 효율적으로 관리가능
  * 시스템 처리량 증가 ( 처리 비용 감소)
    * 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
    * 각각 스레드간의 작업량이 작아 Context Switching이 빠르다.
  
* 단점
  * 데이터 동기화 문제
  * 데드락이 걸리지 않게 주의
  * 전체 프로세스에 영향을 준다.
  * 테스트, 디버깅이 어렵다.

<b>멀티스레드를 더 많이 사용하는 이유는?</b>

* 프로세스에 비해서 데이터 공유가 쉬움 ( 프로세스는 IPC 통신을 이용해야함. )
* Context Swithing이 프로세스가 더 빈번하게 일어남 ( 자원소모가 크다 )

### 9) POJO란?

* Plain Old Java Object의 약자로, 간단한 자바오브젝트라는 뜻이다.
* <b>특징</b>
  * 특정규약에 종속되지 않는다 ( 특정 어플리케이션이나, 클래스를 상속해서 만들면 안된다 )
  * 특정환경에 종속되지 않는다 ( 환경에 독립적이다 )
* POJO란 환경과 기술에 종속되지 않고, 객체지향적인 원리에 충실하게 설계된 자바오브젝트를 뜻한다.

### 10) 컬렉션 프레임워크란?

* 자바에서 컬렉션 프레임워크란, 다수의 데이터를 쉽고 효과적으로 처리할 수 있도록 표준화된 방법을 제공하는 클래스의 집합을 의미합니다. 즉, 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구현화하여 클래스로 구현한 것입니다.

<b>컬렉션 프레임워크의 주요 인터페이스</b>

* List, Set, Map
* 상속관계 
  * Collection<E>
    * List
      * ArrayList, Vector, LinkedList
    * Set
      * HashSet, TreeSet
  
  * Map
    * HashMap, Hashtable,TreeMap,Properties

<b>컬렉션 클래스</b>
* 컬렉션 프레임워크에 속하는 인터페이스를 구현한 클래스를 컬렉션 클래스라고 합니다. 컬렉션 프레임워크의 모든 클래스는 List,Set,Map 인터페이스중 하나의 인터페이스를 구현하고 있습니다.

<b>[더 자세한 내용](https://choiwono.github.io/java/2019/03/15/collection_framework/)</b>

### 11) 제네릭이란?

* 자바에서 제네릭이란 데이터의 타입을 일반화한다는 것을 의미합니다. 제네릭은 클래스나 메소드에서 사용할 내부 데이터타입을 컴파일 시에 미리 지정하는 방법입니다. 이렇게 컴파일 시에 미리 타입검사를 수행하면 여러가지 장점이 있습니다.

  * 컴파일시 강한 타입체크를 할 수 있다. 자바컴파일러는 잘못 사용된 타입 때문에 발생한 문제점을 제거하기 위해 제네릭 코드에 대해 강한 타입체크를 한다. 실행 시 타입 에러가 나는 것보다는 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지하는 편이 좋다.

  * 타입변환을 제거한다. 비제네릭 코드는 불필요한 타입 변환을 하기 때문에 프로그램 성능에 악영향을 끼친다. 분명히 String 타입으로 저장했지만 요소의 값을 찾아올 때는 반드시 형변환을 거쳐서 가져와야 한다. 결국 제네릭 타입을 사용하면 타입변환을 할 필요가 없어서 프로그램 성능이 향상된다.
  
  * JDK 1.5 이전에는 대부분의 클래스나 메소드에서 인수나 반환값으로 Object를 사용했고, 이 경우에 Object를 다시 원하는 값으로 변경하는 작업이 필요했고 이때 오류가 발생할 가능성도 존재했습니다.

  * JDK 1.7부터는 다이아몬드 연산자를 통해서 조금더 간단하게 작성할 수 있게 되었다.
  
  ```java

    Product<Tv,String> product = new Product<Tv,String>();

    // 1.7부터는 선언된 제네릭 타입을 유추해서 자동으로 설정해준다.
    Product<Tv,String> product = new Product<>();
    
  ```

### 12) 캐시와 세션의 공통점과 차이점은?

* 캐시는 클라이언트에 저장되고, 4KB 작은 값만 가질 수 있습니다. 또한 서버와 통신시 html head라인을 통해 전달되며, 중간에 쿠키가 탈취될수 있으므로 보안에 취약한 점을 가지고 있다.

* 세션은 서버에 저장되고, 브라우저 단위로 관리된다. 쿠키에 비해서 큰 용량을 저장할 수 있으나, 상대적으로 서버에 저장하기 때문에 이용자가 많을경우 쿠키에 비해서 부담될 수 있다.

* 예를 들면, spring security는 로그인에 성공하면 내부에 인메모리 방식으로 세션을 저장하고 세션의 키값을 쿠키에 저장해서 다시 리턴해준다. 그럼 로그인이 된 상태에서 네트워크에 요청을 보낼 경우 쿠키에 있는 키값을 통해서 현재 사용자의 유효여부를 판단하고 일치하면 OK, 실패하면 응답코드에 따른 처리를 한다.

* 현재는 Redis 같은 세션 서버를 운영하는 곳도 많다.

### 13) RESTFUL API란?

* URI는 자원을 표현하는데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API 설계하는 중심 규칙입니다.
* 주요 메소드는 POST, GET, DELETE, PUT이 있습니다.

* http란?
  * hyper text transfer protocol, 인터넷에서 데이터를 교환하기 위한 통신규칙
* 참고
  * https://blog.hjf.pe.kr/462

### 14) Java 디자인 패턴

<b>싱글톤 패턴</b>
  * 싱글톤이란?
    * 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우에 사용한다. 단 하나만 생성된다고 해서 이 객체를 싱글톤이라고 한다.
  * 전역변수를 사용하지 않고, 객체를 하나만 생성하도록 하며 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴
  * 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴 ( 동일 인스턴스를 어디서나 사용한다 )

* 장점
  * new 생성자로 계속 인스턴스를 만들 필요가 없다. ( 메모리가 효율적이다 )
  * 싱글톤으로 만들어진 인스턴스는 전역변수이기 때문에 데이터 공유가 쉽다 
    * ex) DBCP에서 많이 사용한다, 쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정 등등
  * 인스턴스가 절대적으로 1개만 존재하는 것을 보증하고 싶을 경우에도 사용
  * 두 번째부터 객체 로딩시간이 현저하게 줄어든다.

* 주의점
  * 수정, 테스트가 어려워 문제점을 찾기 어려움.
  * 멀티쓰레드 환경에서 동기화 처리를 하지 않으면 인스턴스가 두개가 생성이 될 수도 있음.
  * 싱글톤 패턴이 너무 많은 일을 수행하면 OOP의 원칙에 위배된다 (결합도가 너무 높아진다)

<b>팩토리 메소드 패턴</b>
  * 객체 생성을 처리하는 클래스를 서브 클래스에 위임하는 패턴.

* 장점
  * 객체의 생성코드를 별도의 클래스 / 메서드로 분리함으로써, 객체 생성의 변화에 대비하는데 유용하다
  * 특정 기능의 구현은 개별클래스를 통해 제공되는 것이 바람직한 설계다 ( 결합도를 낮추기 위함 )
  * 객체 생성을 전담하는 별도의 Factory 클래스를 이용한다
  * 상속을 통해 하위 클래스에서 적합한 클래스의 객체를 생성한다.

<b>템플릿 메소드 패턴</b>
  * 상위 클래스의 공통적인 로직은 템플릿 메소드를 두고, 메소드 내용중 세부적인 기능에 대한 정의는 추상메소드로 남겨놓으면, 자식 클래스에서 세부 기능을 구현해서 템플릿을 완성하는 패턴이다.
 
* 장점 
  * 즉 전체적으로는 비슷하지만, 세부적으로 내용이 다른 클래스가 있을 때 코드 중복을 최소화 하기에 적합하다.
    * ex) 소시지빵, 참치빵 ( 주요 패티만 다르고 빵과 양상추는 동일하게 들어간다 )
  * 조금 더 자세히 설명하면 공통기능은 상위 클래스에서 정의하고 확장 or 변화가 필요한 부분만 서브 클래스에서 구현하는 것이다.

### 15) 객체지향 5원칙 - SOLID

* <b>단일책임의 원칙 - SRP</b>
  * 클래스나 함수는 하나의 기능만을 책임져야하는 원칙, 즉 응집도는 높이고 결합도는 낮아야한다.
  
* <b>개방폐쇄의 원칙 - OCP</b>
  * 기존에 있는 코드를 수정하지 않고, 수정 변경 확장이 용이하게 프로그래밍을 해야한다. EX) 인터페이스

* <b>리스코프의 치환원칙 - LSP</b>
  * 부모와 자식클래스는 일관성이 있어야한다. Ex) 고양잇과는 그루밍을 한다 -> 샴고양이는 그루밍을 한다 is-a 관계
  
* <b>의존역전 원칙 - DIP</b>
  * 객체지향 프로그래밍에서 의존관계를 맺을 경우, 인터페이스 혹은 추상클래스와 관계를 맺는게 좋다.
  * 의존성 주입 기술을 사용하지 않으면 변경 확장이 용이 하지 않을 수 있다.

* <b>인터페이스 분리원칙 - ISP</b>
  * 객체지향 프로그래밍을 할때, 하나의 구체적인 인터페이스보다는 여러개로 분리해서 만드는 편이 좋다.
  * 하나로 만들경우, 변경이나 확장을 할 경우 어려워질 수 있음

<b>[더 자세한 내용](https://choiwono.github.io/java/2019/06/23/solid/)</b>

### 16) JVM 구조

<b>[내용](https://choiwono.github.io/java/2019/05/05/jvm/)</b>

### 17) synchronized란? 사용하는 방법은?

* 자바에서 말하는 동기화란, 데이터를 thread-safe하게 만드는 방법을 말한다
* 즉, 여러개의 스레드가 하나의 데이터에 접근할 때 데이터의 안정성이 보장이 되지 않으므로 하나의 스레드가 데이터에 접근하고 있을 경우 다른 스레드는 접근을 하지 못하게 막는 것을 이야기한다.

* 적용방법

```java
// 두 코드는 같은 코드입니다.

public synchronized void method(){
    // 처리 코드
}

public void method(){
    synchronized(obj){
        // 처리
    }
}

```

<b>[더 자세한 내용](https://choiwono.github.io/java/2019/06/23/synchronized/)</b>

### 18) String vs StringBuffer, StringBuilder

* String과 다르게 StringBuffer 혹은 StringBuilder는 내부에 buffer라는 작은 임시메모리 공간을 가지고 있고, 문자열을 수정할 경우에 내부 버퍼에서 수정, 삭제가 이루어진다. String 보다 메모리 공간 사용이 효율적이다.
  
* StringBuilder = 싱글스레드 지원, StringBuffer = 멀티스레드 지원

<b>[더 자세한 내용](https://choiwono.github.io/java/2019/05/27/stringBuffer/)</b>

### 19) DI란?

* DI는 프레임워크가 설정 정보를 바탕으로 객체의 의존성이 주입되는 설계 패턴이다. 
* Spring Framework의 핵심 컴포넌트 - DI Container 라고도 부른다

<b>[더 자세한 내용](https://gmlwjd9405.github.io/2018/11/09/dependency-injection.html)</b>

### 20) AOP란?

* 공통 기능을 모듈로 분리해서, 핵심 비즈니스 로직 사이에 영향을 끼치지 않고 끼워넣는 방법
* 관점지향적 프로그래밍이라고도 한다 Ex) 트랜잭션, Logging 처리, 예외 처리

<b>[더 자세한 내용](https://docs.google.com/document/d/1xjXadX6i_7l4xvaWDWzlAl9iec32ntTR_x_S5ikDaks/edit)</b>

### 21) ORM이란?

* 객체지향 프로그래밍과 관계형 데이터 베이스간의 모델 불일치를 해결 하기 위해 모델 - 테이블의 관계를 설정해주는 것
* Ex) JPA, Hibernate

<b>[더 자세한 내용](https://choiwono.github.io/spring/2019/06/12/ORM/)</b>

### 22) Spring 과 Spring Boot의 차이

* 스프링의 복잡한 설정을 간편하게 사용하기 위해 나왔다 -> 개발 생산성을 높이기 위해서
* 스프링에서 해줘야 하는 복잡한 설정 등을 자동 혹은 간편하게 설정 할 수 있다
* 부트의 장점 3가지
  * 설정의 표준 - 자동화
  * 배포가 용이, 내장 Tomcat
  * 의존성 관리가 편리함

<b>[더 자세한 내용](https://choiwono.github.io/java/2019/06/16/spring_boot/)</b>

### 23) GC는 어떻게 작동할까?

* GC는 가비지 컬렉션을 뜻한다. 
* GC는 JVM 위에서 메모리 주소값을 잃은 인스턴스의 메모리를 해제해준다.

### 24) 프로시저

* 쿼리의 함수화라고 생각하면 된다, 원론적으로는 일반함수가 하는 것과 거의 비슷한 일을 하고 개념도 비슷하다.
* 장점
  * 네트워크 경유 시간이 짧아진다, SQL 바로 컴파일해서 사용하기 때문에 웹 어플리케이션에서 호출 하는것보다 네트워크 소요 시간이 적다
  * 보안향상 - 자체적인 보안 설정 기능을 가지고 있고, 세밀한 권한 설정이 가능하다
  * 기능의 추상화 - 특정 어플리케이션에 종속되지 않고 MYSQL을 지원하면 어디서나 사용가능하다
  * 절차적 기능구현 - DBMS 서버에서 사용하는 SQL 쿼리는 절차적인 기능을 제공하지 않음. IF ELSE 사용불가, 그렇지만 스토어드 프로시저에서는 사용이 가능하다
* 단점
  * MYSQL 엔진위에서 실행되기 때문에, CPU 위주의 연산을 해야하는 경우 속도가 느릴 수 있음. 간단한 숫자나 문자열 연산, 또한 한번에 많은 쿼리를 실행해야 할 때 가장 효과가 높다
  * 어플리케이션의 설치나 배포가 복잡해지고 있는만큼, 프로그램 코드가 백엔드 언어와 MYSQL 스토어드 프로그램으로 분리된다면 유지보수가 어려워질 수 있다

### 25) 트리거

* 트리거는 설정한 테이블에 이벤트가 일어날 때 DBMS에서 설정한 프로시저를 실행 시킬 수 있다
* 간단히 설명하면, 회원 테이블에 INSERT가 일어났을 경우 이걸 감지해서 다른 테이블에 로그를 INSERT 시키거나, UPDATE 등을 시킬 수 있음

* 문제점
  * 어플리케이션을 파악해야 하는 부분이 커지고, 트리거를 과도하게 사용할 경우 복잡한 의존성 문제가 생길 수 있다.
  * 대규모 데이터베이스에서는 복잡한 상호 의존성을 관리하기 어렵다.

### 26) join 문

* inner join
  * 두 테이블간의 join 조건을 만족하는 결과만 리턴함
* left join
  * 조인시 왼쪽에 위치한 테이블의 정보를 우선적으로 가져오고, a와 b의 조인 조건이 일치한 데이터를 가져옴
  * ex) select a.*,b.* from a left join b on a.id=b.id, 왼쪽 중심 집합 이라고 생각하면 편함
* right join
  * left join과 반대, 오른쪽을 중심으로 데이터를 가져오고, a와 b의 조인 조건이 일치한 데이터를 가져옴
* full join
  * 테이블 유니온이라고 볼수 있고 양쪽 테이블의 데이터를 모두 가져옴 합집합이라고도 볼수있음.

### 27) 서블릿

* 클라이언트의 요청을 받아 그에 따른 처리를 한뒤, 결과를 되돌려 주는 서버 모듈이다.
* 특징
  * 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트
  * html을 사용하여 요청에 응답한다
  * Java Thread를 이용하여 동작한다
  * MVC 패턴에서 Controller로 이용된다
  * HTML 변경시 서블릿을 재컴파일해야 한다는 단점이 있다.

* 간단한 동작방식
  * 클라이언트에서 서비스를 요청한다. 
  * 서버에서 객체생성 유무를 판단한다
  * 없을 경우에만 객체를 생성한다
  * 컨테이너에서 자바로 변환한다 ( 컨테이너에 내장 JVM이 필요 )
  * 컴파일을 통해서 CLASS 서블릿 객체 생성
  * JSP로 변환하여 클라이언트에게 전송

* 서블릿 컨테이너
  * 서블릿 구조에서 가장 큰 특징
  * 서블릿을 서버에서 실행하기 위한 서버 프로그램, 웹서버는 JVM이 없으므로 JVM을 내장한 컨테이너라는 서블릿 실행환경이 필요하다

* 동작과정
  * 웹 서버는 클라이언트 요청을 컨테이너로 전달한다. 컨테이너는 서블릿이 메모리에 있는지 확인하고 없을시 클라이언트 요청을 처리할 스레드를 생성해서 처리한다
  * 서블릿은 JDBC를 이용해 데이터베이스에 접근할 수 있고, 별도로 제작된 자바 클래스를 통해 다양한 기능을 구현한다
  * 서블릿에서 수행된 결과는 HTML 형식으로 클라이언트에 전달된다

### 28) 자바의 데이터타입 분류

* 자바의 데이터타입은 크게 기본타입(primitive type), 참조타입(reference type)으로 분류된다. 기본 타입이란 정수, 실수,문자,논리 리터럴을 저장하는 타입을 말한다.

* primitive type
  * 정수타입
    * byte, char, short, int, long
  * 실수타입
    * float, double
  * 논리타입
    * boolean
* reference type
  * 배열타입, 열거타입, 클래스, 인터페이스

* 무슨 차이일까?
  * 기본타입의 데이터는 실제 값을 변수안에 저장한다.
  * 참조타입은 메모리의 번지를 값으로 갖는다 ( 즉 실제값이 아닌 메모리 참조값을 값으로 가진다 )  


### 29) 접근제어자의 종류와 특성

* private - 클래스내부 에서만 접근가능
* public - 어디에서나 접근가능
* default - 같은 패키지내에서만 접근가능
* protected - 같은 패키지내에서, 그리고 다른 패키지의 자손 클래스에서 접근가능
* 접근 허용 범위 public > protected > default > private

### 29) NoSQL vs SQL

* MySQL은 SQL을 사용하는 대표적인 데이터베이스이며, SQL을 사용하지 않는 NoSQL이라고 부르는 데이터 베이스도 있습니다.
* 몽고디비는 NoSQL의 대표주자입니다. 
* 사용하는 용도 : 빅데이터, 메시징, 세션 관리등 확장성과 가용성이 필요한 곳
  
| SQL(MySQL)              | NoSQL(몽고디비) |
| ----------------------- | --------------------------------- |
| 규칙에 맞는 데이터 입력   | 자유로운 데이터 입력                |
| 테이블 간 JOIN 지원      | 컬렉션 간 JOIN 미지원               |
| 트랜잭션 지원            | 트랜잭션 미지원                     |
| 안정성, 일관성           | 확장성, 가용성                      |
| 용어(테이블, 로우, 컬럼)  | 용어(컬렉션, 다큐먼트, 필드)        |

### 30) DB 인덱스란? 왜 사용할까?

* RDBM에서 검색을 높이기 위해 사용하는 기술, INDEX는 간단하게 설명하면 색인이다
* 예를들면, 책을 처음부터 끝까지 넘겨서 페이지를 찾는것 보다는 페이지를 알고 있으면 그 페이지 근처에서 몇페이지만 넘기는게 효율적이다.
* B-Tree 방식을 사용한다. 간단히 설명하면 이진트리보다 더 많은 Node를 가지고 있다. 최악의 경우에도 O(logN)을 보장한다.

### 31) MSA란?

* Micro Service Architecture
* 하나의 큰 애플리케이션을 여러개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처
* 예를 들면, 가오가이거 같은 합체 로봇을 하나하나 분리해서 팔, 다리, 날개등으로 분리한게 마이크로 아키텍쳐 서비스다. 또한 분리한 서비스는 단독으로 실행이 가능해야 한다.

* 특징
  * 탄력적이고, 선택적인 확장이 가능하다. 기존에는 주문서비스, 이벤트 서비스등이 모든 어플리케이션에 다 들어가있었다면 사용량이 만약 90:10 이었어도 필요하지 않은 서비스도 확장을 해야했지만 마이크로 서비스 아키텍쳐는 확장이 필요한 서비스만 선택적인 scale out을 할 수 있습니다.
  * 하나의 서비스가 다른 서비스에 영향을 주지 않습니다. 각 서버마다 서비스가 돌아가기 때문에 주문 서버에 문제가 생겨도 주문만 안될뿐, 다른 서비스는 정상적으로 돌아가게 됩니다.
  * 폴리그랏 아키텍처 구성이 가능하다. 각 언어의 특징을 살려, 시간당 트랜잭션이 높고 읽기 작업이 많은 서비스는 Node+Redis로 구현, 트랜잭션 및 안정성이 중요한 서비스는 Spring+RDBS 로 구성이 가능하다

* 단점
  * 관리요소가 늘어난다. MSA는 서비스 수만큼의 인스턴스가 존재하고 서버가 늘어난만큼의 로깅, 모니터링, 배포, 테스트 등등 이러한 문제를 해결하기 위한 복잡한 환경구성을 자동화 하는게 핵심
  * 트랜잭션이 불편하다. 서비스가 각각으로 나뉘기 때문에 각 서비스별로 Local 트랜잭션과 Global 트랜잭션 처리를 해줘야한다.
  * 이러한 문제점으로 인해서, 현재는 API GATEWAY를 통해서 처리한다. API GATEWAY는 단순히 말하면 중간에서 교통정리를 해주는 역활이다.

### 32) 정규화란?

* 데이터베이스의 중복된 데이터를 없애고, 삽입/갱신/삭제시 발생할 수 있는 이상현상들을 방지하기 위해 사용하는 설계 테크닉입니다.

* 특징
  * 불필요한 데이터를 제거한다
  * 데이터 저장을 "논리적"으로 한다
  * 1차, 2차, 3차, BCNF, 4차, 5차 정규화로 나눌 수 있지만 실무적으로 4차 5차까지 사용하는 경우는 많지않다.

* 1차 정규화
  * 1차 정규화는 각 로우마다 컬럼에 해당하는 값이 1개씩만 있어야한다. 컬럼의 원자값을 가지는 것을 뜻한다.
  
* 2차 정규화
  * 2차 정규화는 본격적인 정규화의 시작입니다. 2차 정규화은 테이블의 모든 컬럼이 완전 함수적 종속을 만족하는 것입니다. 기본키중에 특정 컬럼에만 종속된 컬럼이 없어야 한다는 것입니다.

* 3차 정규화
  * 3차 정규화는 기본키를 제외한 속성들 간의 이행적 함수 종속이 없는 것 입니다. 풀어서 말하자면, 기본키 이외의 다른 컬럼이 그외 다른 컬럼을 결정할 수 없는 것입니다. 

* BCNF
  * 3차 정규화가 강화된 버전, 모든 컬럼들의 종속성을 없애는 것 입니다. 3차 정규화와 다른 경우는 후보키가 여러개인 경우에는 3차 정규화를 만족하지만, 이상현상이 발생하는 경우를 해결하기 위한 방법을 뜻합니다. String 3NF라고도 부릅니다. 

### 33) 스프링 부트 2.0 버전의 특징

* 자바 8버전부터 지원, 스프링 프레임워크 5 기반으로 작동
* Spring WebFlux 도입 ( reactive 프로그래밍이 가능하게 변경 ), MSA 지원
* AutoConfigration 지원, 기존에는 내장 톰켓만 지원했지만 -> Netty 등 내장서버구성을 지원해줌
* HTTP2 지원
* 각종 starter 지원 ex) redis, mongoDb 등도 지원해줌

* 질문 받은 내용 정리중

#### 34) HTTP 2의 특징

* 공식적으로 HTTP/2를 지원한다. 기존의 HTTP1.1과 호환성을 유지한다.
* 특징
  * HTTP 헤더 데이터 압축
  * 서버 푸시 기술
  * 요청을 HTTP 파이프라인으로 처리
  * TCP 연결 하나로 여러 요청을 다중화 처리
  * 이런 특징으로 인해서 네트워크 지연시간을 줄이고, 웹 브라우저 렌더링 속도를 향상시킵니다.

#### 35) PK, FK, Index란?

* 다른 테이블의 고유한 식별자값, PK OR Unique 키만 사용가능


#### 36) JPA N+1 문제 해결 방법

* lazy-Loading 처리
* join fetch 처리
* 상황에 따라서 객체관계를 끊기


#### 37) java는 call by value? call by reference?

* 자바는 call by value 방식이다.
* 간단히 설명하면, 기본형 타입 변수와 참조형 타입 변수가 있는데 call by value 방식으로 값을 전달한다.
* 결국, 자바는 call by value 방식으로 값을 복사하여 전달할수도 있고, 메모리 참조값을 전달 할 수 도 있다.
* 복사된 주소값을 받을 수는 있지만, 실제 참조하고 있는 객체(변수) 자체를 받을 수는 없다. 

<b>[더 자세한 내용](https://choiwono.github.io/java/2019/07/05/java/)</b>

#### 38) 자바의 열거 타입에 대해서

* 데이터 중에는 몇 가지로 한정된 값만을 갖는 경우가 있는데, 예를 들면 요일은 월화수목금토일이라는 일곱개의 값만을 가진다. 이와 같이 한정된 값만을 갖는 데이터 타입을 열거타입(enum type)이라고 부른다.

* 아래는 실제 내 프로젝트에서 사용했던 enum type 코드이다. 우선순위를 나눌 값이 3개로 정해져 있었기 때문에 ENUM TYPE을 사용했다. 

```java

public enum PriorityOrderType {
  HIGH, MID, LOW
}

```

* 특징
  * 열거타입은, 상수필드로 만들어진다.
  * 열거타입은 참조타입이다. 즉 사용하게 되면 객체의 주소값을 참조하게 된다.
  * 문자열로 정의되어 있지만, 내부적으로는 정수로 취급되기 때문에 일반 배열로 처리하는 것보다 빠르다.
  * 값의 가짓수가 적을 경우 프로그래머의 실수를 줄이는데 도움이 된다고 생각한다.

* 리팩토링 하기에도 적합하다. 아래 케이스를 보자
* Y, 1, true를 한 묶음으로 처리할 수 있다. 옛날 데이터베이스의 값이 이런식으로 처리된 부분을 많아서 enumType을 사용하면 아래와 같은 케이스에서는 효과적으로 리팩토링이 가능할 것 같다.  

```java

public enum Status {
  Y("1",true),
  N("0",false)
}

```

#### 39) 예외와 예외 클래스

* 자바에서는 에러 이외에 예외(exception) 이라고 부르는 오류가 있다. 예외란 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류를 말한다. 예외가 발생되면 프로그램은 곧바로 종료된다는 점에서 에러와 동일합니다. 그러나 예외는 예외처리를 통해 프로그램을 종료하지 않고 정상 실행 상태가 유지되도록 할 수 있습니다.
  
* 예외의 종류
  * 일반 예외(Exception), 실행 예외(Runtime Exception)

* 무슨차이일까?
  * Exception은 컴파일 시에 예외 처리 코드를 검사하고, Runtime Exception은 컴파일 시에 예외 처리 코드를 검사하지 않는다. 또한 실행예외 클래스들은 Runtime Exception을 상속받는다. 즉, 실행 예외는 자바 컴파일러가 체크를 해주지 않기 때문에 오로지 개발자의 경험에 의해서 예외 처리 코드를 삽입해야 한다.

* Runtime Exception의 종류
  * NullPointerException : 객체 참조값이 없는데 객체를 참조하고 있는 경우
  * ArrayIndexBoundsException : array의 범위를 벗어난 경우, 알고리즘에서 많이 발생한다.
  * NumberFormatException : 문자를 억지로 숫자로 변환한 경우
  * ClassCastException : 형변환을 억지로 시도한 경우, 타입변환 전에 instanceof 연산자로 확인하는게 좋다.