---
layout: post
title: java, Spring 예상 면접관련 질문 정리
date: 2019-05-29 20:25:00 +0900
description:
categories: Java
tags: Spring java
---

블로그에서 좋은 글을 발견해서 나름대로 답변을 어떻게 할까 고민하면서 글을 정리해보려고 한다.

### 1) 자바의 특징에 대해서 말해보시오

* OOP : 객체지향언어로서, 프로그래밍에 필요한 데이터와 기능을 추상화하여 객체로 만들고 그 객체들간의 상호작용을 통해서 프로그램을 완성하는 개발 기법.
  
* 메모리를 관리해주는 언어, 가비지컬렉터가 관리해준다.

* 멀티쓰레드를 구현이 쉽다( 이미 잘 구현된 라이브러리가 많다 )

* JVM 위에서 동작하기 때문에 다양한 애플리케이션을 개발 할 수 있다( 윈도우, 리눅스, 유닉스, 맥 등)

* 풍부한 생태계를 지원한다 ( 강력하고 검증된 오픈소스 라이브러리가 많다 )

* 동적로딩을 지원한다 ( 모든 클래스가 동시에 로딩되는게 아니라, 필요한 시점에 객체를 생성한다. 변경사항이 생긴 객체만 다시 컴파일하면 된다)

### 2) 변수란?

* 값을 저장할 수 있는 메모리 공간

### 3) 클래스, 객체, 인스턴스의 개념

<b>클래스란?</b>

* 객체를 만들어내기 위한 설계도 혹은 틀
* 변수와 메서드의 집합 

<b>객체란?</b>

* 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
* oop의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.
* 소프트웨어 세계에 구현할 대상

<b>인스턴스란?</b>

* 실제 메모리에 할당된 객체
* oop의 관점으로 객체가 메모리에 할당되어 실제 사용되는 경우를 인스턴스라고 부른다  

### 4) 객체지향 프로그램의 특징은?

* 클래스 + 인스턴스, 캡슐화, 은닉화, 상속, 다형성

  * 클래스 : 필요한 데이터를 추상화시켜, 변수와 메서드로 정의한것
  * 인스턴스 : 클래스에서 정의한 내용을 바탕으로 실제 메모리에 할당된 것

  * 캡슐화 : 코드를 재수정없이 재활용하는 것 (관련된 기능과 특성을 한곳에 모아서 분류해서 사용)
  * 은닉화 : 메서드를 통해서만 접근가능, 데이터의 안정성을 보장하고 잘못된 값이 넘어오면 사전에 필터링이 가능하다
  * 상속 : 부모 클래스의 속성과 기능을 그대로 이어받아서 사용할수 있고, 필요한 경우 기능을 다시 재정의해서 사용도가능  
  * 다형성 : 하나의 변수명, 함수명등이 상황에 따라 다르게 사용될 수 있다, 즉 오버로딩 오버라이딩이 가능하다.
    * 오버라이딩 : 부모클래스의 메서드와 같은이름, 매개변수를 재정의하는 것
    * 오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 해서 매개변수에 따라 다르게 호출할 수 있게 하는것

* 장점
  * 코드 재사용이 용이하다
  * 유지보수가 쉽다
  * 대형프로젝트에 적합하다

* 단점
  * 처리속도가 느리다
  * 객체가 많을 경우 용량이 커질 수 있다
  * 설계시 많은 시간과 노력이 필요하다


### 5) 자바의 메모리 영역

* 메소드 영역 : 필드 부분에서 선언된 변수(전역 변수)와 각 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메소드 static 변수, 메서드의 바이트 코드등을 보관한다. jvm이 종료될 때까지 메모리에 남아있다. 그렇기 때문에 전역변수를 많이 사용하면 메모리에 악영향을 끼칠 수 있다
* 스택 영역 : 지역변수( 기본 자료형 등)의 데이터값이 저장되는 공간이 stack 영역이다. stack 영역은 LIFO의 구조를 갖고, 새로운 데이터가 할당될 경우 이전 데이터는 지워진다.
* 힙 영역 : 인스턴스, 배열등이 headp 영역에 저장된다. Heap 영역의 메모리 참조값을 가지고 있다. 메모리가 부족해지면 GC가 Heap 영역에 있는 쓸모없는 데이터를 Young( eden, survive1,2 ), Old 영역에서 정리한다.

### 6) 추상클래스, 메소드란?

* 추상 메서드 : 메서드가 정의는 되어있으나, 내부가 구현되지 않은 메서드
* 추상 클래스 : 추상메소드를 적어도 하나 이상, 가지고 있는 클래스로 자식 클래스에서 오버라이딩이 필요한 추상메서드를 가지고 있기 때문에 객체화 할 수 없다

### 7) 인터페이스란? 

* 추상 메서드로(선언만 되어있는 메소드) 만 이루어져 있으며, 자동으로 static final이 붙는다. 인터페이스를 구현할 클래스에서 implements라는 키워드를 사용해야 한다.

* <b>왜 사용하는가?</b> 협업에 적합하다. 인터페이스는 구현을 하지 않아도 어떤 값을 리턴할 것인지 알기 때문에 협업시에 구현과 동시에, 구현에 따른 결과값에 따른 부가작업을 동시에 진행할 수 있다. 또한 해당 객체가 수정되어도, 개발 코드 부분을 수정하지 않고 구현한 클래스에서만 수정하면 된다.

### 8-1) 프로세스, 쓰레드의 차이점

<b>프로세스란?</b>
* 프로세스는 실행된 프로그램의 인스턴스이다( OS로부터 메모리를 할당받은 독립적인 객체 ). 
* 특징
  * 프로세스는 하나의 독립적인 메모리 공간을 가지고 있다.
  * 기본적으로 프로세스는 하나의 쓰레드를 가지고 있다.
  * 각 프로세스는 별도의 주소공간( 메모리 주소 )에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
  * 그럼 다른 프로세스에 접근할려면? IPC 통신을 사용해야한다 EX) 파이프, 파일, 소켓 등등

<b>스레드란?</b>
* 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 동작하는 작업 단위이다.
* 프로세스가 할당받은 자원을 사용하는 실행의 단위 ( 실제로 일을 할당받아 처리하는 일꾼과 비슷하다 )
* 특징
  * 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
  * 프로세스와 다르게 스레드는 같은 힙공간을 공유한다 ( 스레드는 각각 별도의 Stack과 주소를 가지고 있지만 힙영역은 공유가 가능하다. )
  * 한 스레드가, 프로세스 자원을 변경하면 다른 이웃스레드도 그 변경결과를 즉시 볼 수 있다.

### 8-2) 멀티프로세스, 멀티 스레드의 차이</b>

<b>멀티프로세스란?</b>

* 하나의 프로그램을 여러개의 프로세스로 구성하여, 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.
   
* 장점
  * 여러 개의 자식 프로세스 중 하나에 문제가 발생하면, 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.

* 단점
  * Context Switching에서의 오버헤드가 발생 ( 캐쉬 메모리 초기화 등 ) 무거운 작업을 실행하는 동안 많은 시간이 소요된다.
  * 프로세스는 각각 독립된 메모리 영역을 할당받아서 공유할려면 IPC 통신을 사용해야 한다. ( 통신이 어려움 )

<b>멀티스레드란?</b>

* 하나의 프로그램을 여러개의 스레드로 처리하는것. 윈도우, 리눅스 등 많은 OS가 멀티프로세싱을 지원하고 있지만, 멀티스레딩을 기본으로 하고 있다.
* 웹 서버, 소켓통신 대표적인 멀티스레드의 대표적인 예이다.

* 장점
  * 시스템 자원소모감소
    * 프로세스를 여러개 생성하는 것보다 자원을 효율적으로 관리가능
  * 시스템 처리량 증가 ( 처리 비용 감소)
    * 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
    * 각각 스레드간의 작업량이 작아 Context Switching이 빠르다.
  
* 단점
  * 데이터 동기화 문제
  * 데드락이 걸리지 않게 주의
  * 전체 프로세스에 영향을 준다.
  * 테스트, 디버깅이 어렵다.

<b>멀티스레드를 더 많이 사용하는 이유는?</b>

* 프로세스에 비해서 데이터 공유가 쉬움 ( 프로세는 IPC 통신을 이용해야함. )
* Context Swithing이 프로세스가 더 빈번하게 일어남 ( 자원소모가 크다 )

### 9) POJO란?

* Plain Old Java Object의 약자로, 간단한 자바오브젝트라는 뜻이다.
<b>특징</b>
* 특정규약에 종속되지 않는다 ( 특정 어플리케이션이나, 클래스를 상속해서 만들면 안된다 )
* 특정환경에 종속되지 않는다 ( 환경에 독립적이다 )

* POJO란 환경과 기술에 종속되지 않고, 객체지향적인 원리에 충실하게 설계된 자바오브젝트를 뜻한다.

### 10) 컬렉션 프레임워크란?

* 자바에서 컬렉션 프레임워크란, 다수의 데이터를 쉽고 효과적으로 처리할 수 있도록 표준화된 방법을 제공하는 클래스의 집합을 의미합니다. 즉, 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구현화하여 클래스로 구현한 것입니다.

<b>컬렉션 프레임워크의 주요 인터페이스</b>

* List, Set, Map
* 상속관계 
  * Collection<E>
    * List
      * ArrayList, Vector, LinkedList
    * Set
      * HashSet, TreeSet
  
  * Map
    * HashMap, Hashtable,TreeMap,Properties

<b>컬렉션 클래스</b>
* 컬렉션 프레임워크에 속하는 인터페이스를 구현한 클래스를 컬렉션 클래스라고 합니다. 컬렉션 프레임워크의 모든 클래스는 List,Set,Map 인터페이스중 하나의 인터페이스를 구현하고 있습니다.

### 11) 제네릭이란?

* 자바에서 제네릭이란 데이터의 타입을 일반화한다는 것을 의미합니다. 제네릭은 클래스나 메소드에서 사용할 내부 데이터타입을 컴파일 시에 미리 지정하는 방법입니다. 이렇게 컴파일 시에 미리 타입검사를 수행하면 여러가지 장점이 있습니다.

  * 컴파일시 강한 타입체크를 할 수 있다. 자바컴파일러는 잘못 사용된 타입 때문에 발생한 문제점을 제거하기 위해 제네릭 코드에 대해 강한 타입체크를 한다. 실행 시 타입 에러가 나는 것보다는 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지하는 편이 좋다.

  * 타입변환을 제거한다. 비제네릭 코드는 불필요한 타입 변환을 하기 때문에 프로그램 성능에 악영향을 끼친다. 분명히 String 타입으로 저장했지만 요소의 값을 찾아올 때는 반드시 형변환을 거쳐서 가져와야 한다. 결국 제네릭 타입을 사용하면 타입변환을 할 필요가 없어서 프로그램 성능이 향상된다.
  
  * JDK 1.5 이전에는 대부분의 클래스나 메소드에서 인수나 반환값으로 Object를 사용했고, 이 경우에 Object를 다시 원하는 값으로 변경하는 작업이 필요했고 이때 오류가 발생할 가능성도 존재했습니다.

  * JDK 1.7부터는 다이아몬드 연산자를 통해서 조금더 간단하게 작성할 수 있게 되었다.
  
  ```java

    Product<Tv,String> product = new Product<Tv,String>();

    // 1.7부터는 선언된 제네릭 타입을 유추해서 자동으로 설정해준다.
    Product<Tv,String> product = new Product<>();
    
  ```

### 12) 캐시와 세션의 공통점과 차이점은?

* 캐시는 클라이언트에 저장되고, 4KB 작은 값만 가질 수 있습니다. 또한 서버와 통신시 html head라인을 통해 전달되며, 중간에 쿠키가 탈취될수 있으므로 보안에 취약한 점을 가지고 있다.

* 세션은 서버에 저장되고, 브라우저 단위로 관리된다. 쿠키에 비해서 큰 용량을 저장할 수 있으나, 상대적으로 서버에 저장하기 때문에 이용자가 많을경우 쿠키에 비해서 부담될 수 있다.

* 예를 들면, spring security는 로그인에 성공하면 내부에 인메모리 방식으로 세션을 저장하고 세션의 키값을 쿠키에 저장해서 다시 리턴해준다. 그럼 로그인이 된 상태에서 네트워크에 요청을 보낼 경우 쿠키에 있는 키값을 통해서 현재 사용자의 유효여부를 판단하고 일치하면 OK, 실패하면 응답코드에 따른 처리를 한다.

* 현재는 Redis 같은 세션 서버를 운영하는 곳도 많다.

### 13) RESTFUL API란?

* URI는 자원을 표현하는데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API 설계하는 중심 규칙입니다.
* 주요 메소드는 POST, GET, DELETE, PUT이 있습니다.


### 14) Java 디자인 패턴

<b>싱글톤 패턴</b>
  * 전역변수를 사용하지 않고, 객체를 하나만 생성하도록 하며 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴
  * 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴 ( 동일 인스턴스를 어디서나 사용한다 )

* 장점
  * new 생성자로 계속 인스턴스를 만들 필요가 없다. ( 메모리가 효율적이다 )
  * 싱글톤으로 만들어진 인스턴스는 전역변수이기 때문에 데이터 공유가 쉽다 ex) DBCP에서 많이 사용한다
    * EX) 쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정 등등
  * 인스턴스가 절대적으로 1개만 존재하는 것을 보증하고 싶을 경우에도 사용
  * 두 번째부터 객체 로딩시간이 현저하게 줄어든다.

* 주의점
  * 수정, 테스트가 어려워 문제점을 찾기 어려움.
  * 멀티쓰레드 환경에서 동기화 처리를 하지 않으면 인스턴스가 두개가 생성이 될 수도 있음.
  * 싱글톤 패턴이 너무 많은 일을 수행하면 OOP의 원칙에 위배된다. ( 결합도가 너무 높아진다 )

<b>팩토리 메소드 패턴</b>
  * 객체 생성을 처리하는 클래스를 서브 클래스에 위임하는 패턴.

* 장점
  * 객체의 생성코드를 별도의 클래스 / 메서드로 분리함으로써, 객체 생성의 변화에 대비하는데 유용하다
  * 특정 기능의 구현은 개별클래스를 통해 제공되는 것이 바람직한 설계다 ( 결합도를 낮추기 위함 )
  * 객체 생성을 전담하는 별도의 Factory 클래스를 이용한다
  * 상속을 통해 하위 클래스에서 적합한 클래스의 객체를 생성한다.

<b>템플릿 메소드 패턴</b>
  * 상위 클래스의 공통적인 로직은 템플릿 메소드를 두고, 메소드 내용중 세부적인 기능에 대한 정의는 추상메소드로 남겨놓으면, 자식 클래스에서 세부 기능을 구현해서 템플릿을 완성하는 패턴이다.
 
* 장점 
  * 즉 전체적으로는 비슷하지만, 세부적으로 내용이 다른 클래스가 있을 때 코드 중복을 최소화 하기에 적합하다.
    * ex) 소시지빵, 참치빵 ( 주요 패티만 다르고 빵과 양상추는 동일하게 들어간다 )
  * 조금 더 자세히 설명하면 공통기능은 상위 클래스에서 정의하고 확장 or 변화가 필요한 부분만 서브 클래스에서 구현하는 것이다.

