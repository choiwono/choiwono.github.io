---
layout: post
title:  "[javascript] ES6 문법"
date:   2019-01-07
excerpt: "javascript,es6"
java: true
tag:
- es6
- javascript

comments: true
---

# 자바스크립트 ES6 문법

## 1. Scope

* 변수 선언
* 다음 세가지를 기억한다

1. const를 기본으로 사용한다.
2. 변경이 될수 있는 변수는 let을 사용한다.
3. var는 사용하지 않는다.

## 1.1 let

* 기존의 var을 대체한다. 
* 블록스코프 단위로 자신을 정의한 block(function, for, if) 안에서 유효한 변수
* 명확한 변수 사용으로 개발자의 생산성을 향상시켜준다.

```javascript

let let1 = 1; 
function letTest() { 
    console.log(let1);  
    if(let1 == 1) { 
        let let2 = 2; 
    } 
    console.log(let2); 
}

```

## 1.2 const

* 기존에 없던 상수형 변수, 다만 담긴값이 불변값이 아닌 변수의 식별자가 재할당 될수 없다.
* 객체 내부의 값은 변경가능, ME 객체 자체는 바꿀수 없다.

```javascript

ex)1
const ME = { "name": "ES6" } 
console.log(ME.name); //ES6 
ME.name = "ES7"; 
console.log(ME.name); //ES7, ME 자체는 재할당 불가능, 객체 내부의 값은 변경가능
console.log(ME); 

ex)2
const list = ["godori", "irodog", "roodig"];
list.push("dorigo");
console.log(list);  // ["godori","irodog","roodig","dorigo"]

const list1 = ["goodori", "irodog", "roodig"];
list2 = [].concat(list1, "dorigo");
console.log(list1 === list2);  // 들어있는 값은 받지만 false값을 출력!!

```

* react등에서 state값 변경, 주로 리덕스를 이용해 새로운 값을 계속 반환할 때 immutable array를 많이 사용한다.

## 1.3 import, export

* import - 다른 스크립트의 특정함수, 객체를 사용하기 위한 키워드
* export - 반대로 스클립트 내의 특정함수, 객체를 내보낼수 있다.

```javascript

function plus(x,y) {
    return x+y;
}
const doublePl = Math.Pl * 2;
export {plus, doublePl}

// 다른파일에서 export된 객체를 사용할 수 있다.
import { plus, doulbePl } from 'math';
console.log(plus(3,4)); // 7
console.log(doublePl); // 6.283185307179586

// 이 방식으로도 export 가능
export default function plus(x, y) { 
    return x + y; 
}

```

## 1.4 arrow function

* 기존의 function보다 훨씬 간결함
* 항상 익명함수이다.
* 생성자를 사용할 수 없다.

```javascript

var plus = function(a,b) {
    var result = a + b;
    return result;
}

let plus = (a,b) => {
    let result = a + b;
    return result;
}

```

* 가장 중요한 특징 중 첫번째는 간결한 구문이다.

```javascript

var result = function(a,b) { return a*b; }
var result2 = (a,b) => a * b;

```

* 두번쨰는 arrow function의 this값은 해당 스코프의 this값과 같다.
* 기존의 ES5에서의 this는 주로 self(that)나 bind를 사용하여 this를 속박하고 싶다.
* ES6에서는 이러한 this의 번거로움을 줄이고 해당 arrow function을 감싸고 있는 블록을 this로 가리킨다.

```javascript

function phone() {
    var self = this,
    name = "Galaxy s",
    version = 6;

    versionUp = function() {
        console.log(this);
        self.version++;
    }; 
}

function phone() {
    this.sName = "Galaxy s",
    this.sVersion = 0;

    test => {
        console.log(this);
        this.version++;
    };
}

```

## 2.1 String

*  **startsWith(), endsWith()** : 앞뒤로 일치하는 문자열이 있는지 판단하고 true, false값 리턴
* **includes()** : 문자열이 포함돼 있는지 판단합니다.

```javascript

let str = "godori is irodog";
str.startsWith("godori");  // true
str.endsWith("irodog");    // true
str.includes("is");        // true

```

## 2.2 Array
 
* **for of 순회** 

* for in 순회는 내가 가지고 있지 않는 상위 배열의 값도 가지고 올 수 있지만
* for of 순회는 value 순회가 가능하므로 for in보다 문제의 가능성이 적다.

```javascript

// for in 순회
var data = ["irodog", "roodig"];
Array.prototype.getIndex = "godori";

for(let idx in data){
    console.log(data[idx]); // irodog, roodig, godori
}

// for of 순회
var data = ["irodog", "roodig"];
Array.prototype.getIndex = "godori";

for(let value of data){ // value에 있는 값만 나옴
    console.log(value); // irodog, roodig
}

```

* **spread 연산자**   
* 표기법 : [ ... arr] 처럼 표기한다.  
* 원본 배열값은 바꾸지 않고, 열거 가능한 요소를 하나씩 전개한다.
  
```javascript

let data = ["godori", "irodog", "roodig"];
let newData = [...data];
console.log( newData === data );  // false, newData에 값을 담아도 원본배열의 값은 바꾸지 않는다.

function sum(a,b,c){
    return a+b+c;
}
let arr = [100,200,300]; 

console.log( sum.apply(null, arr) );  // 인자를 배열 형태로 받아 출력
console.log( sum(...arr) );           // 이렇게 써도 동일한 결과 출력, 간략하게 쓸수있음.

```

* **FROM 함수**  

* JS 함수에는 arguments라는 유사 배열이 존재하며, 함수 호출시 입력한 인자들을 저장하고     있다. 하지만 이는 arguments 객체의 인스턴스로, 배열과 흡사하지만 엄밀한 의미로 배열이    아니다. 따라서 배열 메서드인 map 등은 arguments에 사용 불가능하다

```javascript

function apendDoggy(){
    let newArray = Array.from(arguments);
    let newData = newArray.map(function(value) {
        return value + "🐶";
    });

    console.log(newData);
}

apendDoggy("bow","wow"); // ["bow🐶","wow🐶"]

```

* from 함수를 사용하면 유사 배열을 배열로 만들어준다. 가령, DOM조작시 querySelectAll로    얻은 노드 리스트를 from 을 통해 배열로 변경할 수도 있다.

 [참고_url](https://velog.io/@godori/ES6-%EC%A0%95%EB%A6%AC-vpjmrh6hhe);
 [참고_url](https://hudi.kr/es6-%EB%AC%B8%EB%B2%95%EC%9C%BC%EB%A1%9C-%EB%8B%A4%EC%8B%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/);