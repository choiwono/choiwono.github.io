---
layout: post
title:  "[TTL] 2019-01-16, 트랜잭션, 쓰레드풀, 커넥션풀"
date:   2019-01-07
excerpt: "트랜잭션,쓰레드풀,커넥션풀"
java: true
tag:
- Thread
- connection pool
- Thread local
- 트랜잭션

comments: true
---

## JDBC 작동순서

1. 접속을 한다 / 접속을 끊는다. DB 접속을 할때 오버헤드가 많이 발생한다.
2. SQL 준비
3. 바인딩
4. SQL 실행
5. 한번 읽어온다.
6. NEXT()로 값이 FALSE가 나올때까지 읽는다.
7. 작업이 종료되면 CLOSE를 한다.

## 커넥션풀

* 가장 자원소모가 큰건 연결 할 때이다.

* 커넥션풀은 자동으로 DB와 미리 연결을 맺는다
* DBMS <-> 커넥션풀

* 많은 쓰레드가 데이터 커넥션을 요청할 경우 더이상 요청될 커넥션 객체가 없을경우
* 사용자는 사용할 커넥션 객체가 없기 때문에 계속 대기하게 된다.
* 즉 DBMS가 더이상 사용하지 않는 커넥션 객체가 없을 경우 사용자는 사용할수 있는
* 커넥션 객체가 없기 때문에 계속 대기하게 된다.

* 또한 SQL이 수행시간이 길어 커넥션을 사용하고 CLOSE를 하지 않으면 전체시스템에
* 악영향을 줄수가 있다.

* 스태틱은 메모리에 1개만 있어야한다. ( 그래서 보통 커넥션풀은 메모리에 1개만 존재한다 )
* HikariCP를 가지는 객체는 메모리에 하나만 있으면 좋겠다.
* 메모리에 하나만 있는 객체를 우리는 '싱글턴' 객체라고 한다.


## 흐름정리

#### 트랜잭션 데이터 처리는 한 커넥션 단위로 처리한다

1. 브라우저가 URL로 SERVLET을 요청한다.
2. SERVLET에서 요청이 들어오면 값을 처리한다.
3. BOARDSERVICE에서 커넥션을 생성한다.
4. 하나의 쓰레드에서는 값을 공유할 수 있다 ( THREAD LOCAL )
5. 쓰레드로컬에는 해당 SQL을 처리하면서 값을 저장한다.
6. BOARDSERVICE에서 COMMIT이 완료 되면 커넥션을 닫아준다.

* 쓰레드로컬은 스태틱으로 선언한다. ( 메모리당 1개만 선언 가능하다 )
* 쓰레드로컬은 커넥션을 이름으로 사용한다. ( set method )
* 그러므로 커넥션마다 다른 값을 가질 수 있다. ( get method를 통해서 호출가능 )

* 필드가 없을 경우에는 동시에 호출되도 문제가 없다.
* 공유객체를 사용할떄는 공유객체는 필드값을 가지고 있지 않다.
* 그렇지만 공유객체에서 상수값을 공유하고 싶은경우에는 static final로 지정해놓을경우에는
* 서로 값을 공유해도 상수이기때문에 문제가 없다.